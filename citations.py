# -*- coding: utf-8 -*-
"""Citations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18qIWlThZORiHxeAq1l8BEz-MX0K9uTbJ
"""

import networkx as nx

# 1. Charger le fichier d‚Äôar√™tes en ignorant les lignes de commentaires
file_path = "cit-DBLP.edges"  # Assure-toi que ce fichier est bien dans ton r√©pertoire de travail

# 2. Construction du graphe orient√©
G = nx.read_edgelist(file_path,
                     create_using=nx.DiGraph(),
                     nodetype=int,
                     comments='%')

# 3. Informations de base sur le r√©seau
print("‚úÖ R√©seau charg√© avec succ√®s !")
print("Nombre de n≈ìuds :", G.number_of_nodes())
print("Nombre d‚Äôar√™tes :", G.number_of_edges())

# 4. Exemple d'affichage de quelques ar√™tes
print("\nQuelques ar√™tes du r√©seau :")
for i, edge in enumerate(G.edges()):
    if i >= 5:
        break
    print(edge)

# 5. Sauvegarde du graphe en format .gexf pour visualisation dans Gephi
nx.write_gexf(G, "cit-DBLP.gexf")
print("\nüîÅ Graphe sauvegard√© au format 'cit-DBLP.gexf'")

import matplotlib.pyplot as plt

in_degrees = [d for n, d in G.in_degree()]
out_degrees = [d for n, d in G.out_degree()]

plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.hist(in_degrees, bins=100, color='skyblue')
plt.title("Distribution des degr√©s entrants (citations re√ßues)")
plt.xlabel("Degr√© entrant")
plt.ylabel("Nombre de n≈ìuds")

plt.subplot(1, 2, 2)
plt.hist(out_degrees, bins=100, color='salmon')
plt.title("Distribution des degr√©s sortants (citations faites)")
plt.xlabel("Degr√© sortant")
plt.ylabel("Nombre de n≈ìuds")

plt.tight_layout()
plt.show()

largest_weak_cc = max(nx.weakly_connected_components(G), key=len)
largest_strong_cc = max(nx.strongly_connected_components(G), key=len)

print("Taille du plus grand composant faiblement connect√© :", len(largest_weak_cc))
print("Taille du plus grand composant fortement connect√© :", len(largest_strong_cc))

G_scc = G.subgraph(largest_strong_cc).copy()
avg_shortest_path = nx.average_shortest_path_length(G_scc)
diameter = nx.diameter(G_scc)

print("Longueur moyenne des chemins :", avg_shortest_path)
print("Diam√®tre du graphe :", diameter)

clustering = nx.average_clustering(G.to_undirected())
density = nx.density(G)

print("Coefficient de clustering moyen :", clustering)
print("Densit√© du graphe :", density)

top_in_degree = sorted(G.in_degree(), key=lambda x: x[1], reverse=True)[:10]
print("Top 10 articles les plus cit√©s :", top_in_degree)

centrality_closeness = nx.closeness_centrality(G_scc)
top_closeness = sorted(centrality_closeness.items(), key=lambda x: x[1], reverse=True)[:10]

betweenness = nx.betweenness_centrality(G_scc)
top_betweenness = sorted(betweenness.items(), key=lambda x: x[1], reverse=True)[:10]

!pip install cdlib

from cdlib import algorithms, evaluation
from cdlib.viz import plot_community_graph
import matplotlib.pyplot as plt

# R√©seau dirig√© => pour Louvain et Infomap on travaille avec une version non dirig√©e
G_undirected = G.to_undirected()

louvain_communities = algorithms.louvain(G_undirected)
print("Louvain - Nombre de communaut√©s :", len(louvain_communities.communities))

label_prop_communities = algorithms.label_propagation(G_undirected)
print("Label Propagation - Nombre de communaut√©s :", len(label_prop_communities.communities))

import networkx as nx
from networkx.algorithms.community import k_clique_communities

# Appliquer k-clique (par exemple avec k = 4)
k = 4
kclique_communities_gen = list(k_clique_communities(G_undirected, k))
print(f"K-Clique (k={k}) - Nombre de communaut√©s :", len(kclique_communities_gen))

# Afficher les 3 premi√®res communaut√©s
for i, community in enumerate(kclique_communities_gen[:3], 1):
    print(f"Communaut√© {i} (taille {len(community)}):", list(community))

# Pour Louvain
plot_community_graph(G_undirected, louvain_communities)
plt.title("Communaut√©s d√©tect√©es par Louvain")
plt.show()

!pip install cdlib python-louvain

import networkx as nx
from cdlib import algorithms, evaluation, NodeClustering
from networkx.algorithms.community import k_clique_communities

# 1. Conversion en graphe non dirig√© (n√©cessaire pour certains algos comme Louvain)
G_undirected = G.to_undirected()

# 2. Louvain
louvain_communities = algorithms.louvain(G_undirected)
print("Louvain - Nombre de communaut√©s :", len(louvain_communities.communities))

# 3. Propagation des labels
label_prop_communities = algorithms.label_propagation(G_undirected)
print("Label Propagation - Nombre de communaut√©s :", len(label_prop_communities.communities))

# 4. K-Clique
k = 4
kclique_raw = list(k_clique_communities(G_undirected, k))
kclique_communities = NodeClustering(communities=[list(c) for c in kclique_raw],
                                     graph=G_undirected,
                                     method_name="k-clique")
print("K-Clique (k=4) - Nombre de communaut√©s :", len(kclique_communities.communities))

# 5. √âvaluation de la modularit√©
mod_louvain = evaluation.newman_girvan_modularity(G_undirected, louvain_communities)
mod_label = evaluation.newman_girvan_modularity(G_undirected, label_prop_communities)
mod_kclique = evaluation.newman_girvan_modularity(G_undirected, kclique_communities)

# 6. Affichage des r√©sultats
print("\n‚úÖ Modularit√© :")
print(f"Louvain : {mod_louvain.score:.4f}")
print(f"Label Propagation : {mod_label.score:.4f}")
print(f"K-Clique (k={k}) : {mod_kclique.score:.4f}")